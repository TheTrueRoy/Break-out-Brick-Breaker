!SESSION 2021-04-26 13:59:30.363 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\robsc\Desktop\Project_Milliken-20210421T140216Z-001\Project_Milliken\.metadata\.bak_0.log
Created Time: 2021-04-26 13:59:43.459

!ENTRY org.eclipse.egit.ui 2 0 2021-04-26 13:59:43.459
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\robsc'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-04-26 19:12:50.792
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{
	
	private UIManager uiManager;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long lastBreak = 0;

	//Settings
		int diff = Game.getDifficulty();
		double emptyChance = 0.1;
		int scale = 10;
	//Power UPs 
		boolean drill = false;
		boolean magnet = false;
	//Upgrades
		int bombRadius = 200;
		int bombCooldown = 30;
		int bombDamage = 3;
		double bombPassiveRecharge = 0.1;
		double paddleBoost = 0;
		double comboMult = 1;
			int combo = 0;
			UIImage[] digitsC;
	//Level
		int DiffSpeedMult = 4;
		int DiffScoreMult = 10;
	
	ArrayList<Brick> bricks = new ArrayList<Brick>();
	
	UIImage charge, box;
	
	UIImage paddle;
	int paddleX = 0, paddleW = 400, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);
	
	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);
	
	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = 50, speed = DiffSpeedMult*(diff+1), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);
	
	int points = 0;
	UIImage[] digits;
	
	public BrickState(Handler handler) {
		super(handler);
	}
	
	public void init() {
		diff = Game.getDifficulty();
		
		speed = DiffSpeedMult*(Game.getDifficulty()+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
		
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX, (int)ballY, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime();
	}
	
	public void tick() {
		//Checks if the ball is just bouncing left and right aimlessly


		if ((lastBreak + 10000000000l) < System.nanoTime()) {
			lastBreak = System.nanoTime();
			ballD = Math.toRadians(90);
			ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		}
		
		//Most of the games code
		if (keyManager.right == true) { 
			paddle.setX(paddle.getX()+paddleSpeed);
		}
		if (keyManager.left == true) { 
			paddle.setX(paddle.getX()-paddleSpeed);
		}
		if (keyManager.space == true) { //Explosion
			if (timeBomb >= bombCooldown) {
				bombActive = true;
			}
		}
		if (keyManager.esc == true) { 
			State.setState(handler.getGame().menuState);
		}
		
		//Trippy side portal nonsense
		if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
			paddle.setX(paddle.getX()-screenSize.width);
		if (paddle.getX() < 0)//Moves primary paddle to replace clone on right
			paddle.setX(paddle.getX()+screenSize.width);
		
		//Moves clone to the side more likely to require it next as well as removing it after teleportation
		if (paddle.getX()+paddleW/2 < screenSize.width/2) {
			paddle2.setX(paddle.getX()+screenSize.width);
		} else {
			paddle2.setX(paddle.getX()-screenSize.width);
		}
		
		pBounds.x = (int) paddle.getX();
		pBounds2.x = (int) paddle2.getX();
		bBounds.x = (int) ball.getX();
		bBounds.y = (int) ball.getY();
		
		if (pBounds.intersects(bBounds)) {
			ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI))/2;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			combo=0; //Resets combo count when the paddle is hit
			lastBreak = System.nanoTime();
		} else if (pBounds2.intersects(bBounds)) {
			ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			combo=0; //Resets combo count when the paddle is hit
			lastBreak = System.nanoTime(); //player interaction resets ball reset CD
		}
		if (ball.getY() > screenSize.height-ballW) {
			State.setState(handler.getGame().menuState);
		} else if (ball.getY() < 0) {
			ball.setY(0);
			ballD = -ballD;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
		}
		if (ball.getX() > screenSize.width-ballW) {
			ball.setX(screenSize.width-ballW);
			ballD = Math.PI-ballD;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
		} else if (ball.getX() < 0) {
			ball.setX(0);
			ballD = Math.PI-ballD;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
		}
		
		Iterator<Brick> it = bricks.iterator();
		ArrayList<Brick> broken = new ArrayList<Brick>();
		ArrayList<Brick> bombBroken = new ArrayList<Brick>();
		boolean hFlip = drill, vFlip = drill;
		int hitDMG = 3-Game.getDifficulty();
		if (bombActive)
			hitDMG = bombDamage;
		bombWasActive = false;
		while(it.hasNext()) {
			Brick e = it.next();
			Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
			if (r.intersects(bBounds)) {
				if (bombActive) { //Bomb
					bombWasActive = true;
					timeBomb = 0;
				}
				if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
					hFlip = true;
					ballD = Math.PI-ballD;
					ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				} else if (!vFlip) { //It hits the top/near the top, it bounces back
					vFlip = true;
					ballD = -ballD;
					ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				}
				lastBreak = System.nanoTime();
				broken.add(e);
			}
			int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
			if (bombActive && dist < bombRadius*bombRadius) {
				bombBroken.add(e); //Bricks that break if bomb explodes
			}
		}
		if (bombBroken.size() > 0 && broken.size() > 0)
			broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
		it = broken.iterator();
		while(it.hasNext()) {
			combo++;
			points+=brickReward*combo*comboMult;
			if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;
			
			Brick e = it.next();
			double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
			double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
			System.out.println(dist);
			if (!bombActive)
				uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
			else
				uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(int)(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(int)(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
			e.damage(hitDMG+(int)(combo/20));
			if (e.getHealth() < 1) {
				bricks.remove(e);
			}
		}
		if (bombActive && bombWasActive) {
			for (int i = 0; i < 70; i++) {
				double wid = Math.random()*60+30;
				uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
			}
			bombActive = false;
		}

		if (bricks.size() == 0)
			init();
		
		ball.setX((float)(ball.getX()+ballVX));
		ball.setY((float)(ball.getY()+ballVY));
		
		String count;
		//Updates SCORE Counter
		count = Integer.toString(points);
		if (digits != null) {
			for (int i = 0; i < digits.length; i++) {
				digits[i].setActive(false);
			}
		}
		digits = new UIImage[count.length()];
		for (int i = 0; i < count.length(); i++) {
			digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
			uiManager.addObject(digits[i]);
		}
		
		//Updates COMBO Counter
		count = Integer.toString(combo);
		if (digitsC != null) {
			for (int i = 0; i < digitsC.length; i++) {
				digitsC[i].setActive(false);
			}
		}
		digitsC = new UIImage[count.length()];
		for (int i = 0; i < count.length(); i++) {
			if (combo == 0) {
				speed = DiffSpeedMult*(Game.getDifficulty()+1);
				digitsC[i] = new UIImage(10+i*62, 110, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
			}
			else if (combo < 10) {
				digitsC[i] = new UIImage(10+i*62, 110, 54, 66, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
			}
			else {
				speed = DiffSpeedMult*(Game.getDifficulty()+1) + 2;
				digitsC[i] = new UIImage(10+i*62, 110, 54, 66, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
			}
			uiManager.addObject(digitsC[i]);
		}
		
		//Draws CHARGE bar
		if (bombActive) {
			charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
			charge.setImage(Assets.pal[(time/2)+3]);
		} else if ((int)timeBomb == bombCooldown) {
			charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
			charge.setImage(Assets.pal[2]);
		} else {
			charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
			charge.setImage(Assets.pal[0]);
		}
		
		time++;
		//Makes Ambiance and ticks the UI
		if (time >= 2) {
			ifcombo > 10
			for (int i = 0; i < 2; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				time = 0;
			}
		}
		if (!bombActive)
			timeBomb+=bombPassiveRecharge;
		if (timeBomb > bombCooldown)
			timeBomb = bombCooldown;
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-26 19:12:50.793
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-26 19:12:50.794
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-26 19:12:50.803
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{
	
	private UIManager uiManager;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long lastBreak = 0;

	//Settings
		int diff = Game.getDifficulty();
		double emptyChance = 0.1;
		int scale = 10;
	//Power UPs 
		boolean drill = false;
		boolean magnet = false;
	//Upgrades
		int bombRadius = 200;
		int bombCooldown = 30;
		int bombDamage = 3;
		double bombPassiveRecharge = 0.1;
		double paddleBoost = 0;
		double comboMult = 1;
			int combo = 0;
			UIImage[] digitsC;
	//Level
		int DiffSpeedMult = 4;
		int DiffScoreMult = 10;
	
	ArrayList<Brick> bricks = new ArrayList<Brick>();
	
	UIImage charge, box;
	
	UIImage paddle;
	int paddleX = 0, paddleW = 400, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);
	
	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);
	
	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = 50, speed = DiffSpeedMult*(diff+1), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);
	
	int points = 0;
	UIImage[] digits;
	
	public BrickState(Handler handler) {
		super(handler);
	}
	
	public void init() {
		diff = Game.getDifficulty();
		
		speed = DiffSpeedMult*(Game.getDifficulty()+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
		
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX, (int)ballY, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime();
	}
	
	public void tick() {
		//Checks if the ball is just bouncing left and right aimlessly


		if ((lastBreak + 10000000000l) < System.nanoTime()) {
			lastBreak = System.nanoTime();
			ballD = Math.toRadians(90);
			ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		}
		
		//Most of the games code
		if (keyManager.right == true) { 
			paddle.setX(paddle.getX()+paddleSpeed);
		}
		if (keyManager.left == true) { 
			paddle.setX(paddle.getX()-paddleSpeed);
		}
		if (keyManager.space == true) { //Explosion
			if (timeBomb >= bombCooldown) {
				bombActive = true;
			}
		}
		if (keyManager.esc == true) { 
			State.setState(handler.getGame().menuState);
		}
		
		//Trippy side portal nonsense
		if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
			paddle.setX(paddle.getX()-screenSize.width);
		if (paddle.getX() < 0)//Moves primary paddle to replace clone on right
			paddle.setX(paddle.getX()+screenSize.width);
		
		//Moves clone to the side more likely to require it next as well as removing it after teleportation
		if (paddle.getX()+paddleW/2 < screenSize.width/2) {
			paddle2.setX(paddle.getX()+screenSize.width);
		} else {
			paddle2.setX(paddle.getX()-screenSize.width);
		}
		
		pBounds.x = (int) paddle.getX();
		pBounds2.x = (int) paddle2.getX();
		bBounds.x = (int) ball.getX();
		bBounds.y = (int) ball.getY();
		
		if (pBounds.intersects(bBounds)) {
			ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI))/2;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			combo=0; //Resets combo count when the paddle is hit
			lastBreak = System.nanoTime();
		} else if (pBounds2.intersects(bBounds)) {
			ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			combo=0; //Resets combo count when the paddle is hit
			lastBreak = System.nanoTime(); //player interaction resets ball reset CD
		}
		if (ball.getY() > screenSize.height-ballW) {
			State.setState(handler.getGame().menuState);
		} else if (ball.getY() < 0) {
			ball.setY(0);
			ballD = -ballD;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
		}
		if (ball.getX() > screenSize.width-ballW) {
			ball.setX(screenSize.width-ballW);
			ballD = Math.PI-ballD;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
		} else if (ball.getX() < 0) {
			ball.setX(0);
			ballD = Math.PI-ballD;
			ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
		}
		
		Iterator<Brick> it = bricks.iterator();
		ArrayList<Brick> broken = new ArrayList<Brick>();
		ArrayList<Brick> bombBroken = new ArrayList<Brick>();
		boolean hFlip = drill, vFlip = drill;
		int hitDMG = 3-Game.getDifficulty();
		if (bombActive)
			hitDMG = bombDamage;
		bombWasActive = false;
		while(it.hasNext()) {
			Brick e = it.next();
			Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
			if (r.intersects(bBounds)) {
				if (bombActive) { //Bomb
					bombWasActive = true;
					timeBomb = 0;
				}
				if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
					hFlip = true;
					ballD = Math.PI-ballD;
					ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				} else if (!vFlip) { //It hits the top/near the top, it bounces back
					vFlip = true;
					ballD = -ballD;
					ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				}
				lastBreak = System.nanoTime();
				broken.add(e);
			}
			int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
			if (bombActive && dist < bombRadius*bombRadius) {
				bombBroken.add(e); //Bricks that break if bomb explodes
			}
		}
		if (bombBroken.size() > 0 && broken.size() > 0)
			broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
		it = broken.iterator();
		while(it.hasNext()) {
			combo++;
			points+=brickReward*combo*comboMult;
			if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;
			
			Brick e = it.next();
			double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
			double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
			System.out.println(dist);
			if (!bombActive)
				uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
			else
				uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(int)(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(int)(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
			e.damage(hitDMG+(int)(combo/20));
			if (e.getHealth() < 1) {
				bricks.remove(e);
			}
		}
		if (bombActive && bombWasActive) {
			for (int i = 0; i < 70; i++) {
				double wid = Math.random()*60+30;
				uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
			}
			bombActive = false;
		}

		if (bricks.size() == 0)
			init();
		
		ball.setX((float)(ball.getX()+ballVX));
		ball.setY((float)(ball.getY()+ballVY));
		
		String count;
		//Updates SCORE Counter
		count = Integer.toString(points);
		if (digits != null) {
			for (int i = 0; i < digits.length; i++) {
				digits[i].setActive(false);
			}
		}
		digits = new UIImage[count.length()];
		for (int i = 0; i < count.length(); i++) {
			digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
			uiManager.addObject(digits[i]);
		}
		
		//Updates COMBO Counter
		count = Integer.toString(combo);
		if (digitsC != null) {
			for (int i = 0; i < digitsC.length; i++) {
				digitsC[i].setActive(false);
			}
		}
		digitsC = new UIImage[count.length()];
		for (int i = 0; i < count.length(); i++) {
			if (combo == 0) {
				speed = DiffSpeedMult*(Game.getDifficulty()+1);
				digitsC[i] = new UIImage(10+i*62, 110, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
			}
			else if (combo < 10) {
				digitsC[i] = new UIImage(10+i*62, 110, 54, 66, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
			}
			else {
				speed = DiffSpeedMult*(Game.getDifficulty()+1) + 2;
				digitsC[i] = new UIImage(10+i*62, 110, 54, 66, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
			}
			uiManager.addObject(digitsC[i]);
		}
		
		//Draws CHARGE bar
		if (bombActive) {
			charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
			charge.setImage(Assets.pal[(time/2)+3]);
		} else if ((int)timeBomb == bombCooldown) {
			charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
			charge.setImage(Assets.pal[2]);
		} else {
			charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
			charge.setImage(Assets.pal[0]);
		}
		
		time++;
		//Makes Ambiance and ticks the UI
		if (time >= 2) {
			ifcombo > 10
			for (int i = 0; i < 2; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				time = 0;
			}
		}
		if (!bombActive)
			timeBomb+=bombPassiveRecharge;
		if (timeBomb > bombCooldown)
			timeBomb = bombCooldown;
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-26 19:12:50.804
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-26 19:12:50.804
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-04-27 09:51:35.986 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-04-27 09:51:42.714
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-04-27 09:51:44.065
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-27 09:51:44.065
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@625f5712,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5e62ca19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.core.runtime 4 0 2021-04-27 09:51:46.815
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.mylyn.tasks.ui/icons/eview16/task-list.gif
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:293)
	at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:206)
	at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:239)
	at org.eclipse.jface.resource.URLImageDescriptor.access$2(URLImageDescriptor.java:231)
	at org.eclipse.jface.resource.URLImageDescriptor$URLImageFileNameProvider.getImagePath(URLImageDescriptor.java:58)
	at org.eclipse.swt.internal.DPIUtil.validateAndGetImagePathAtZoom(DPIUtil.java:419)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:687)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:227)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImageWithDefault(ResourceManager.java:195)
	at org.eclipse.jface.resource.ImageRegistry.get(ImageRegistry.java:206)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:218)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:228)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:794)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:196)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jface 4 0 2021-04-27 09:51:46.817
!MESSAGE Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.resolve(PlatformURLPluginConnection.java:73)
	at org.eclipse.core.internal.boot.PlatformURLHandler.openConnection(PlatformURLHandler.java:69)
	at org.eclipse.osgi.internal.url.URLStreamHandlerProxy.openConnection(URLStreamHandlerProxy.java:123)
	at java.base/java.net.URL.openConnection(URL.java:1101)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.toFileURL(PlatformURLConverter.java:34)
	at org.eclipse.core.runtime.FileLocator.toFileURL(FileLocator.java:261)
	at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:243)
	at org.eclipse.jface.resource.URLImageDescriptor.access$2(URLImageDescriptor.java:231)
	at org.eclipse.jface.resource.URLImageDescriptor$URLImageFileNameProvider.getImagePath(URLImageDescriptor.java:58)
	at org.eclipse.swt.internal.DPIUtil.validateAndGetImagePathAtZoom(DPIUtil.java:419)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:687)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:227)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImageWithDefault(ResourceManager.java:195)
	at org.eclipse.jface.resource.ImageRegistry.get(ImageRegistry.java:206)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:218)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:228)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:794)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:196)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.core.runtime 4 0 2021-04-27 09:51:46.818
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.mylyn.tasks.ui/icons/eview16/task-list.gif
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:293)
	at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:206)
	at org.eclipse.jface.resource.URLImageDescriptor.getStream(URLImageDescriptor.java:166)
	at org.eclipse.jface.resource.URLImageDescriptor.getImageData(URLImageDescriptor.java:134)
	at org.eclipse.jface.resource.URLImageDescriptor.access$3(URLImageDescriptor.java:132)
	at org.eclipse.jface.resource.URLImageDescriptor$URLImageDataProvider.getImageData(URLImageDescriptor.java:78)
	at org.eclipse.swt.internal.DPIUtil.validateAndGetImageDataAtZoom(DPIUtil.java:404)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:732)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:282)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:227)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImageWithDefault(ResourceManager.java:195)
	at org.eclipse.jface.resource.ImageRegistry.get(ImageRegistry.java:206)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:218)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:228)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:794)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:196)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jface 2 0 2021-04-27 09:51:46.819
!MESSAGE The image could not be loaded: URLImageDescriptor(platform:/plugin/org.eclipse.mylyn.tasks.ui/icons/eview16/task-list.gif)
!STACK 0
org.eclipse.jface.resource.DeviceResourceException: Unable to create resource URLImageDescriptor(platform:/plugin/org.eclipse.mylyn.tasks.ui/icons/eview16/task-list.gif)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:229)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImageWithDefault(ResourceManager.java:195)
	at org.eclipse.jface.resource.ImageRegistry.get(ImageRegistry.java:206)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImageFromURI(SWTPartRenderer.java:218)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.getImage(SWTPartRenderer.java:228)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.createTab(StackRenderer.java:794)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.processContents(LazyStackRenderer.java:196)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:114)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.core.runtime 4 0 2021-04-27 09:51:46.995
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.mylyn.tasks.ui/icons/eview16/task-list.gif
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:293)
	at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:206)
	at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:239)
	at org.eclipse.jface.resource.URLImageDescriptor.access$2(URLImageDescriptor.java:231)
	at org.eclipse.jface.resource.URLImageDescriptor$URLImageFileNameProvider.getImagePath(URLImageDescriptor.java:58)
	at org.eclipse.swt.internal.DPIUtil.validateAndGetImagePathAtZoom(DPIUtil.java:419)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:687)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.getImage(TrimStack.java:818)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.updateTrimStackItems(TrimStack.java:883)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.createWidget(TrimStack.java:638)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:346)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:227)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:94)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:37)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolControlRenderer.createWidget(ToolControlRenderer.java:129)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.TrimBarRenderer.processContents(TrimBarRenderer.java:109)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:688)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jface 4 0 2021-04-27 09:51:46.996
!MESSAGE Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.resolve(PlatformURLPluginConnection.java:73)
	at org.eclipse.core.internal.boot.PlatformURLHandler.openConnection(PlatformURLHandler.java:69)
	at org.eclipse.osgi.internal.url.URLStreamHandlerProxy.openConnection(URLStreamHandlerProxy.java:123)
	at java.base/java.net.URL.openConnection(URL.java:1101)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.toFileURL(PlatformURLConverter.java:34)
	at org.eclipse.core.runtime.FileLocator.toFileURL(FileLocator.java:261)
	at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:243)
	at org.eclipse.jface.resource.URLImageDescriptor.access$2(URLImageDescriptor.java:231)
	at org.eclipse.jface.resource.URLImageDescriptor$URLImageFileNameProvider.getImagePath(URLImageDescriptor.java:58)
	at org.eclipse.swt.internal.DPIUtil.validateAndGetImagePathAtZoom(DPIUtil.java:419)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:687)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:274)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.getImage(TrimStack.java:818)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.updateTrimStackItems(TrimStack.java:883)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.createWidget(TrimStack.java:638)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:346)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:227)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:94)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:37)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolControlRenderer.createWidget(ToolControlRenderer.java:129)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.TrimBarRenderer.processContents(TrimBarRenderer.java:109)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:688)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.core.runtime 4 0 2021-04-27 09:51:46.997
!MESSAGE Invalid input url:platform:/plugin/org.eclipse.mylyn.tasks.ui/icons/eview16/task-list.gif
!STACK 0
java.io.IOException: Unable to resolve plug-in "org.eclipse.mylyn.tasks.ui".
	at org.eclipse.core.internal.runtime.PlatformURLPluginConnection.parse(PlatformURLPluginConnection.java:64)
	at org.eclipse.core.internal.runtime.FindSupport.find(FindSupport.java:293)
	at org.eclipse.core.runtime.FileLocator.find(FileLocator.java:206)
	at org.eclipse.jface.resource.URLImageDescriptor.getStream(URLImageDescriptor.java:166)
	at org.eclipse.jface.resource.URLImageDescriptor.getImageData(URLImageDescriptor.java:134)
	at org.eclipse.jface.resource.URLImageDescriptor.access$3(URLImageDescriptor.java:132)
	at org.eclipse.jface.resource.URLImageDescriptor$URLImageDataProvider.getImageData(URLImageDescriptor.java:78)
	at org.eclipse.swt.internal.DPIUtil.validateAndGetImageDataAtZoom(DPIUtil.java:404)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:732)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:282)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:287)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:265)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.getImage(TrimStack.java:818)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.updateTrimStackItems(TrimStack.java:883)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.createWidget(TrimStack.java:638)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:346)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:227)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:94)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:37)
	at org.eclipse.e4.ui.workbench.renderers.swt.ToolControlRenderer.createWidget(ToolControlRenderer.java:129)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.TrimBarRenderer.processContents(TrimBarRenderer.java:109)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:688)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-27 09:51:48.123
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\robsc'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.debug.ui 4 120 2021-04-27 10:31:12.837
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:22.454
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:20:22.456
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:20:22.456
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:23.966
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2)))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:20:23.966
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:20:23.967
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:23.982
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2)))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:23.983
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:23.984
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:26.478
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2)))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:20:26.479
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:20:26.479
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:28.490
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:20:28.490
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:20:28.491
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:28.500
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:28.500
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:28.500
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:31.003
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:20:31.003
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:20:31.004
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:33.331
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:33.332
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:33.332
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:33.339
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-04-27 11:20:33.340
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:36.335
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:36.336
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:36.336
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:36.423
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:36.424
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:36.424
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:36.431
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-04-27 11:20:36.431
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:38.022
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:20:38.023
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:20:38.023
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:38.033
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:38.034
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:38.034
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:38.671
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:38.672
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:38.672
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:38.680
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-04-27 11:20:38.681
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:40.535
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:20:40.536
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:20:40.536
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:45.800
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:45.801
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:45.801
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:45.809
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-04-27 11:20:45.809
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:47.687
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:47.689
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:47.689
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:47.698
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-04-27 11:20:47.698
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:49.445
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:49.446
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:49.446
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:49.626
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:49.627
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:49.627
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:49.635
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-04-27 11:20:49.635
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:50.903
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:50.904
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:50.904
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:54.742
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.parseCompilationUnit(ToggleBreakpointAdapter.java:1221)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.parseCompilationUnit(ToggleBreakpointAdapter.java:1209)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleFieldOrMethodBreakpoints(ToggleBreakpointAdapter.java:1420)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpoints(ToggleBreakpointAdapter.java:1343)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpointsWithEvent(ToggleBreakpointAdapter.java:1573)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.doIt(ToggleBreakpointAction.java:105)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.runWithEvent(ToggleBreakpointAction.java:83)
	at org.eclipse.debug.ui.actions.RulerToggleBreakpointActionDelegate.runWithEvent(RulerToggleBreakpointActionDelegate.java:116)
	at org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy.execute(ActionDelegateHandlerProxy.java:281)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.ui.actions.ContributedAction.runWithEvent(ContributedAction.java:176)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.triggerAction(AbstractTextEditor.java:3030)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.mouseDoubleClick(AbstractTextEditor.java:3056)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:200)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:54.743
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.parseCompilationUnit(ToggleBreakpointAdapter.java:1221)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.parseCompilationUnit(ToggleBreakpointAdapter.java:1209)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleFieldOrMethodBreakpoints(ToggleBreakpointAdapter.java:1420)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpoints(ToggleBreakpointAdapter.java:1343)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpointsWithEvent(ToggleBreakpointAdapter.java:1573)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.doIt(ToggleBreakpointAction.java:105)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.runWithEvent(ToggleBreakpointAction.java:83)
	at org.eclipse.debug.ui.actions.RulerToggleBreakpointActionDelegate.runWithEvent(RulerToggleBreakpointActionDelegate.java:116)
	at org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy.execute(ActionDelegateHandlerProxy.java:281)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.ui.actions.ContributedAction.runWithEvent(ContributedAction.java:176)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.triggerAction(AbstractTextEditor.java:3030)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.mouseDoubleClick(AbstractTextEditor.java:3056)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:200)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:54.743
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.parseCompilationUnit(ToggleBreakpointAdapter.java:1221)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.parseCompilationUnit(ToggleBreakpointAdapter.java:1209)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleFieldOrMethodBreakpoints(ToggleBreakpointAdapter.java:1420)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpoints(ToggleBreakpointAdapter.java:1343)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpointsWithEvent(ToggleBreakpointAdapter.java:1573)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.doIt(ToggleBreakpointAction.java:105)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.runWithEvent(ToggleBreakpointAction.java:83)
	at org.eclipse.debug.ui.actions.RulerToggleBreakpointActionDelegate.runWithEvent(RulerToggleBreakpointActionDelegate.java:116)
	at org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy.execute(ActionDelegateHandlerProxy.java:281)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.ui.actions.ContributedAction.runWithEvent(ContributedAction.java:176)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.triggerAction(AbstractTextEditor.java:3030)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.mouseDoubleClick(AbstractTextEditor.java:3056)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:200)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.debug.ui 4 150 2021-04-27 11:20:54.744
!MESSAGE Failed to parse CU for: BrickState.java
!STACK 0
java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleFieldOrMethodBreakpoints(ToggleBreakpointAdapter.java:1422)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpoints(ToggleBreakpointAdapter.java:1343)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpointsWithEvent(ToggleBreakpointAdapter.java:1573)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.doIt(ToggleBreakpointAction.java:105)
	at org.eclipse.debug.ui.actions.ToggleBreakpointAction.runWithEvent(ToggleBreakpointAction.java:83)
	at org.eclipse.debug.ui.actions.RulerToggleBreakpointActionDelegate.runWithEvent(RulerToggleBreakpointActionDelegate.java:116)
	at org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy.execute(ActionDelegateHandlerProxy.java:281)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.ui.actions.ContributedAction.runWithEvent(ContributedAction.java:176)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.triggerAction(AbstractTextEditor.java:3030)
	at org.eclipse.ui.texteditor.AbstractTextEditor$1.mouseDoubleClick(AbstractTextEditor.java:3056)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:200)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:54.752
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:54.752
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:54.753
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:20:59.839
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2))))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:20:59.840
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:20:59.840
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:04.576
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:21:04.577
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:21:04.577
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:07.601
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:21:07.602
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:21:07.602
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:09.970
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:21:09.970
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:21:09.971
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:09.978
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-04-27 11:21:09.978
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1036)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:10.060
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )))/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:21:10.060
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:21:10.061
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:14.598
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )) )/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-04-27 11:21:14.599
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-04-27 11:21:14.599
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:14.607
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )) )/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-04-27 11:21:14.608
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-04-27 11:21:14.608
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-04-27 11:21:22.675
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package tsg.ttt.main.states;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.util.ArrayList;
import java.util.Iterator;

import tsg.ttt.main.Game;
import tsg.ttt.main.Handler;
import tsg.ttt.main.control.keyboard.KeyManager;
import tsg.ttt.main.gfx.Assets;
import tsg.ttt.main.ui.*;
import tsg.ttt.main.ui.particles.brickParticle;
import tsg.ttt.main.ui.particles.starParticle;

public class BrickState extends State{

	private UIManager uiManager;
	boolean paused = false, over = false;
	Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
	KeyManager keyManager = handler.getKeyManager();
	int timeEsc = 0;
	double timeBomb = 0; boolean bombActive = false; boolean bombWasActive;
	int time = 0;
	long overTime = 0;
	long lastBreak = 0;

	//Settings
	int diff = Game.getDifficulty();
	double emptyChance = 0;
	int scale = 4; //Above 20 causes bugs
	String control = "keyboard";
	//Power UPs 
	boolean drill = false;
	
	//Upgrades
	int bombRadius = 200;
	int bombCooldown = 30;
	int bombDamage = 0;
	double bombPassiveRecharge = 0.1;
	double paddleBoost = 0;
	double comboMult = 1;
	double ballSizeMult = 1;
	
	//Combo
	int combo = 0;
	UIImage[] digitsC;
	
	//Level
	int DiffSpeedMult = 4;
	int DiffScoreMult = 10;

	ArrayList<Brick> bricks = new ArrayList<Brick>();

	UIImage charge, box;
	UIFilter pause = new UIFilter(0,0,screenSize.width,screenSize.height,Assets.pal[0],0);
	UITiltImage gameover = new UITiltImage(screenSize.width/2-500, screenSize.height/10*4-128/7*5-750, 1000, 128/7*10, Assets.gameover, 0.05, 0.00025);

	UIImage paddle;
	int paddleX = 0, paddleW = 400/(diff+1)*2, paddleH = 100;
	Rectangle pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage paddle2;
	Rectangle pBounds2 = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

	UIImage ball;
	double ballD, ballX, ballY, ballVX, ballVY; 
	int ballW = (int)(50*ballSizeMult), speed = DiffSpeedMult*(3+(diff+1)), paddleSpeed = (int) (10+paddleBoost);
	int brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;
	Rectangle bBounds = new Rectangle(0,0,ballW,ballW);

	long points = 0;
	int svpb = (int) paddleBoost;
	UIImage[] digits;

	public BrickState(Handler handler) {
		super(handler);
	}

	public void set() {
		diff*=1.3;
		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ball.setX(screenSize.width/2-ballW/2); ball.setY(screenSize.height-paddleH-200-ballW/2); ballVX = 0; ballVY = 0;
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		lastBreak = System.nanoTime()-7000000000l;
	}

	public void init() {
		paused = false;
		over = false;

		diff = Game.getDifficulty();
		paddleBoost = svpb;
		if (diff == 2)
			paddleBoost += 5;
		paddleSpeed = (int) (10+paddleBoost);
		paddleW = 400/(diff+1)*2;
		pBounds = new Rectangle(0,screenSize.height-paddleH,paddleW,paddleH);

		speed = DiffSpeedMult*(+1);
		points = 0;
		combo = 0;
		bombActive = false;
		brickReward = (int) (Math.pow(diff,2)+1) * DiffScoreMult;

		ballD = Math.random()*90+45;
		ballD = Math.toRadians(ballD);
		ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
		timeEsc = 0;
		timeBomb = 0;
		uiManager = new UIManager(handler);
		handler.getMouseManager().setUIManager(uiManager);
		paddle = new UIImage(screenSize.width/2-paddleW/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[0]);
		paddle2 = new UIImage(screenSize.width*3/2, screenSize.height-paddleH, paddleW, paddleH, Assets.bricks[5]);
		ball = new UIImage((int)ballX-ballW/2, (int)ballY-ballW/2, ballW, ballW, Assets.o);
		uiManager.addObject(paddle);
		uiManager.addObject(paddle2);
		uiManager.addObject(ball);
		charge = new UIImage(0, 0, 0, 105, Assets.bricks[5]);
		uiManager.addObject(charge);
		box = new UIImage(0,0,1050,105,Assets.box);
		uiManager.addObject(box);
		bricks.clear();
		for(int i = 0; i < 8*scale; i++) {
			for(int j = 0; j < 10*scale; j++) {
				int health = Math.min(Math.max((int)((Math.random()*11.0-1)/(i+1)*scale*2),1),9);
				Brick brick = new Brick(j*160/scale+120+80/scale*(i%2),i*60/scale+180,160/scale,60/scale,health);
				double real = Math.random();
				if (real > emptyChance) {
					bricks.add(brick);
					uiManager.addObject(brick);
				}
			}
		}
		if(control.equals("mouse")) {
			paddle2.setVisible(false);
		}
		lastBreak = System.nanoTime();
	}

	public void tick() {
		if (!paused && !over) {
			overTime = 0;
			//Checks if the ball is just bouncing left and right aimlessly
			if ((lastBreak + 10000000000l) < System.nanoTime()) {
				lastBreak = System.nanoTime();
				ballD = Math.toRadians(90);
				ballX = screenSize.width/2; ballY = screenSize.height-paddleH-100; ballVX = Math.cos(ballD)*3; ballVY = Math.sin(ballD)*3;
			}

			//Most of the games code
			if (control.equals("keyboard")) {
				if (keyManager.right == true) { 
					paddle.setX(paddle.getX()+paddleSpeed);
				}
				if (keyManager.left == true) { 
					paddle.setX(paddle.getX()-paddleSpeed);
				}
			} else {
				paddle.setX(MouseInfo.getPointerInfo().getLocation().x-paddleW/2);
			}
			if (keyManager.space == true) { //Explosion
				if (timeBomb >= bombCooldown) {
					bombActive = true;
				}
			}
			if (keyManager.esc == true) { 
				Game.setGold((int) (Game.getGold()+points/100000));
				State.setState(handler.getGame().menuState);
			}

			//Trippy side portal nonsense
			if (paddle.getX() > screenSize.width)//Moves primary paddle to replace clone on left
				paddle.setX(paddle.getX()-screenSize.width);
			if (paddle.getX()+paddleW < 0)//Moves primary paddle to replace clone on right
				paddle.setX(paddle.getX()+screenSize.width);

			//Moves clone to the side more likely to require it next as well as removing it after teleportation
			if (paddle.getX()+paddleW/2 < screenSize.width/2) {
				paddle2.setX(paddle.getX()+screenSize.width);
			} else {
				paddle2.setX(paddle.getX()-screenSize.width);
			}

			pBounds.x = (int) paddle.getX();
			pBounds2.x = (int) paddle2.getX();
			bBounds.x = (int) ball.getX();
			bBounds.y = (int) ball.getY();

			if (pBounds.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (Math.max((ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2),Math.PI*2(-1*(ball.getX()+ball.getWidth()-paddle.getX())/(paddleW+ballW)*Math.PI%(Math.PI*2) )) )/2);
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime();
			} else if (pBounds2.intersects(bBounds)) {
				ballD = (-ballD - (Math.PI - (ball.getX()+ball.getWidth()-paddle2.getX())/(paddleW+ballW)*Math.PI))/2;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
				combo=0; //Resets combo count when the paddle is hit
				lastBreak = System.nanoTime(); //player interaction resets ball reset CD
			}
			if (ball.getY() > screenSize.height-ballW) {
				over = true;
			} else if (ball.getY() < 0) {
				ball.setY(0);
				ballD = -ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}
			if (ball.getX() > screenSize.width-ballW) {
				ball.setX(screenSize.width-ballW);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			} else if (ball.getX() < 0) {
				ball.setX(0);
				ballD = Math.PI-ballD;
				ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
			}

			Iterator<Brick> it = bricks.iterator();
			ArrayList<Brick> broken = new ArrayList<Brick>();
			ArrayList<Brick> bombBroken = new ArrayList<Brick>();
			boolean hFlip = drill, vFlip = drill;
			int hitDMG = 3-Game.getDifficulty();
			if (bombActive)
				hitDMG = bombDamage;
			bombWasActive = false;
			while(it.hasNext()) {
				Brick e = it.next();
				Rectangle r = new Rectangle((int)e.getX(), (int)e.getY(), e.getWidth(), e.getHeight());
				if (r.intersects(bBounds)) {
					if (bombActive) { //Bomb
						bombWasActive = true;
						timeBomb = 0;
					}
					if (!hFlip && bBounds.y+bBounds.height/3 < r.y+r.height && bBounds.y+bBounds.height*2/3 > r.y) { //If it blatantly hits the side of the brick, it bounces of the side
						hFlip = true;
						ballD = Math.PI-ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					} else if (!vFlip) { //It hits the top/near the top, it bounces back
						vFlip = true;
						ballD = -ballD;
						ballVX = Math.cos(ballD)*speed; ballVY = Math.sin(ballD)*speed;
					}
					lastBreak = System.nanoTime();
					broken.add(e);
				}
				int dist = (int) (Math.pow(bBounds.x+ballW/2-(r.x+r.width/2),2) + Math.pow(bBounds.y+ballW/2-(r.y+r.height/2),2));
				if (bombActive && dist < bombRadius*bombRadius) {
					bombBroken.add(e); //Bricks that break if bomb explodes
				}
			}
			if (bombBroken.size() > 0 && broken.size() > 0)
				broken.addAll(bombBroken); //Combines broken bricks if bomb has collided and will damage bricks
			it = broken.iterator();
			while(it.hasNext()) {
				combo++;
				points+=brickReward*combo*comboMult;
				if (timeBomb < bombCooldown && !bombActive)
					timeBomb+=10;

				Brick e = it.next();
				double ratio = Math.PI*1/2-Math.atan2(ball.getX()+ballW/2-(e.getX()+e.getWidth()), ball.getY()+ballW/2-(e.getY()+e.getHeight()));
				double dist = Math.pow(ball.getX()+ballW/2-(e.getX()+e.getWidth()/2),2) + Math.pow(ball.getY()+ballW/2-(e.getY()+e.getHeight()/2),2);
				if (!bombActive)
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)-ballVX, (float)ballVY, e.getHealth()));
				else
					uiManager.addObject(new brickParticle(e.getX(), e.getY(), e.getWidth(), e.getHeight(), screenSize.height, (float)(Math.cos(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))-ballVX), (float)(Math.sin(ratio)*(20*(Math.pow(bombRadius,2)-dist)/Math.pow(bombRadius,2))+ballVY), e.getHealth()));
				e.damage(hitDMG+(int)(combo/20));
				if (e.getHealth() < 1) {
					bricks.remove(e);
				}
			}
			if (bombActive && bombWasActive) {
				for (int i = 0; i < 70; i++) {
					double wid = Math.random()*60+30;
					uiManager.addObject(new starParticle((float)(ball.getX()+wid/2), (float)(ball.getY()+wid/2), (int)wid, (int)wid, (int)(Math.random()*40)+80, 120, (float)Math.random()*9-3, (float)Math.random()*9-3));
				}
				bombActive = false;
			}

			if (bricks.size() == 0) {
				points*=2;
				set();
			}

			ball.setX((float)(ball.getX()+ballVX));
			ball.setY((float)(ball.getY()+ballVY));

			String count;
			//Updates SCORE Counter
			count = Long.toString(points);
			if (digits != null) {
				for (int i = 0; i < digits.length; i++) {
					digits[i].setActive(false);
				}
			}
			digits = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				digits[i] = new UIImage(10+i*62, 16, 54, 66, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				uiManager.addObject(digits[i]);
			}

			//Updates COMBO Counter
			count = Integer.toString(combo);
			if (digitsC != null) {
				for (int i = 0; i < digitsC.length; i++) {
					digitsC[i].setActive(false);
				}
			}
			digitsC = new UIImage[count.length()];
			for (int i = 0; i < count.length(); i++) {
				if (combo == 0) {
					speed = DiffSpeedMult*(diff+1);
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbers[Character.getNumericValue(count.charAt(i))]);
				}
				else if (combo < 10) {
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersBLUE[Character.getNumericValue(count.charAt(i))]);
				}
				else {
					speed = DiffSpeedMult*(diff+1) + 2;
					digitsC[i] = new UIImage(25+i*31, 90, 27, 33, Assets.numbersRED[Character.getNumericValue(count.charAt(i))]);
				}
				uiManager.addObject(digitsC[i]);
			}

			//Draws CHARGE bar

			if (timeBomb < 0) {
				timeBomb = 0;
				bombActive = false;
			}
			
			if (bombActive) {
				timeBomb-=0.1;
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[(time%30)/15+4]);
			} else if ((int)timeBomb == bombCooldown) {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[2]);
			} else {
				charge.setWidth((int)(1050.0*timeBomb/bombCooldown));
				charge.setImage(Assets.pal[1]);
			}

			time++;
			//Makes Ambiance and ticks the UI
			if (combo > 10) {
				//for (int i = 0; i < 4; i++) {
				double wid = Math.random()*20+20;
				uiManager.addObject(new starParticle((float)(Math.random()*ballW+ball.getX()-wid/2), (float)(Math.random()*ballW+ball.getY()-wid/2), (int)wid, (int)wid, 20, 20, (float)ballVX*1.5f, (float)ballVY*1.5f));
				//}
			}
			if (!bombActive)
				timeBomb+=bombPassiveRecharge*(2-diff);
			if (timeBomb > bombCooldown)
				timeBomb = bombCooldown;
			
			if (over) {
				Game.setGold((int)(Game.getGold()+points/100000));
				uiManager.addObject(pause);
				uiManager.addObject(gameover);
				pause.setAlpha(0);
				gameover.setY(screenSize.height/10*4-128/7*5-800);
			}

		} else if (over) {
			if (keyManager.esc == true) { 
				State.setState(handler.getGame().menuState);
			}
			overTime++;
			pause.setAlpha(Math.min(100,overTime)/150.0);
			gameover.setY(screenSize.height/10*4-128/7*5-800+8*Math.min(100,overTime));
		}
		//Ticks the UI
		uiManager.tick();
	}

	public void render(Graphics g) { //Renders everything
		uiManager.render(g);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
